<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
  <script src="https://d3js.org/d3.v5.min.js"></script>
</head>

<script
    src="https://code.easypz.io/easypz.latest.min.js">
</script>
<script src="https://unpkg.com/javascript-lp-solver/prod/solver.js"></script>

<style>
    body {
        font-family: Arial, Helvetica, sans-serif;
        margin: 5%;
        background-color: beige;
    }

    svg {
        margin: 1%;
        background-color: white;
    }

    .algorithm_header {
        font-size: 2em;
        font-weight: bold;
        margin-top: 100px;
        margin-bottom: 20px;
    }

    .rowDiv {
        margin-top: 20px;
    }

</style>

<body>
</body>

<script src="./dist/dist.js"></script>
<script>
    const svg_height = 300
    const svg_width = 600

    const svg_height_s = 300
    const svg_width_s = 600
    const svg_height_m = 800
    const svg_width_m = 1600
    const svg_height_l = 1600
    const svg_width_l = 3200

    const attr_height = 15
    const table_width = 70
    const depth_distance = 150
    const header_height = 20
    const table_vert_space = 100


    let drawGraph = (svg, g, algorithm = undefined) => {
        let line = d3.line()
            .curve(d3.curveBasis);

        visg = svg.append('g')
            .attr('transform', 'translate(20, 20)')

        // draw tables
        tablegroups = visg.selectAll(".tables")
            .data(g.tables)
            .enter()
            .append('g')
            .attr('transform', d => 
                "translate(" + (d.depth*depth_distance) + "," 
                + g.tableIndex[d.depth].indexOf(d) * table_vert_space + ")" )

        tablegroups.append('rect')
            .attr('width', table_width)
            .attr('height', d => d.attributes.length * attr_height + header_height)  
            .attr('fill', 'black')
            .attr('stroke', 'gray')

        tablegroups.append('text')
            .attr('x', table_width/2)
            .attr('y', attr_height/2 + 5)
            .attr('text-anchor', 'middle')
            .attr('fill', 'white')
            .attr('font-size', '0.7em')
            .attr("font-family", "Arial")
            .text(d => d.header + " w:" + d.weight)
        
        attrgroups = tablegroups.selectAll('.attrs')
            .data(d => d.attributes)
            .enter()
            .append('g')
            .attr('transform', (d, i) => "translate(0, " + (header_height + (i)*attr_height) + ")")
            
        attrgroups.append("rect")
            .attr("width", table_width)
            .attr("height", attr_height)
            .attr("fill", "#ccc")
            .attr("stroke", "white")
            .attr("stroke-width", 2)

        attrgroups.append('text')
            .attr('x', table_width/2)
            .attr('y', attr_height/2 + 3)
            .attr('text-anchor', 'middle')
            .attr('font-size', '0.7em')
            .attr("font-family", "Arial")
            .text(d => d.attr + " w:" + d.weight)

        let get_1st_coord = (d) => 
            [d.leftTable.depth * depth_distance + table_width,
            d.leftTable.attributes.indexOf(d.att1)*attr_height + header_height + attr_height/2 + g.tableIndex[d.leftTable.depth].indexOf(d.leftTable)*table_vert_space]
       
        let get_2nd_coord = (d) => {
            if (d.leftTable.depth != d.rightTable.depth)
                return [d.rightTable.depth * depth_distance, 
                    d.rightTable.attributes.indexOf(d.att2)*attr_height + header_height + attr_height/2 + g.tableIndex[d.rightTable.depth].indexOf(d.rightTable)*table_vert_space]
            else return [d.leftTable.depth * depth_distance + table_width,
                d.rightTable.attributes.indexOf(d.att2)*attr_height + header_height + attr_height/2 + g.tableIndex[d.rightTable.depth].indexOf(d.rightTable)*table_vert_space]    
        }

        // draw edges
        edges = visg.selectAll('.edges')
            .data(g.edges)
            .enter()
            .append('path')
            .attr('stroke', 'black')
            .attr('fill', 'none')
            .attr('d', d => {
                first = get_1st_coord(d)
                second = get_2nd_coord(d)
                return line(
                    [first, 
                    [first[0] + depth_distance*0.2, first[1]],
                    [second[0] + (d.leftTable.depth == d.rightTable.depth ? 1 : -1)*depth_distance*0.2, second[1]],
                    second]
                )
            })

        d3.select(svg.node().parentNode)
            .append('div').append('text')
            .text('crossings: ' + g.getEdgeCrossings() + ', tables: ' + g.tables.length + ', edges: ' + g.edges.length)
            .style('font-family', 'Arial')
            .attr('class', 'crossing_count')

        if (algorithm != undefined && algorithm.elapsedTime != undefined){
            d3.select(svg.node().parentNode)
            .append('div').append('text')
            .text('time: ' + algorithm.elapsedTime + 'ms')
            .style('font-family', 'Arial')
            .attr('class', 'crossing_count')
        }
    }

    lpTest = () => {
        g = new Graph()
        t = new Table("a", "a", true, 0)
        b = new Table("b", "b", true, 1)
        c = new Table("c", "c", true, 1)

        g.addTable(t)
        g.addTable(b)
        g.addTable(c)

        a1 = new Attribute(t, "a1")
        t.attributes.push(a1)
        a2 = new Attribute(t, "a2")
        t.attributes.push(a2)
        b1 = new Attribute(t, "b1")
        t.attributes.push(b1)
        b2 = new Attribute(b, "b2")
        b.attributes.push(b2)

        g.setExactWeights()
        g.sortGraph()

        e = new Edge(t, a1, t, b1)
        g.addEdge(e)
        e = new Edge(t, a2, b, b2)
        g.addEdge(e)

        let algorithm = new LPFormulation(g)
        algorithm.arrange()

        return g
    }

    makeGraphWithAlgorithm = (rowDiv, seed, size, algorithmName = undefined) => {
        let depth, tableDistribution, cur_svg_width, cur_svg_height, algorithm;

        switch (size) {
            case 's':
                depth = 4;
                tableDistribution = [2, 3];
                cur_svg_width = svg_width_s;
                cur_svg_height = svg_height_s;
                break;
            case 'm':
                depth = 10;
                tableDistribution = [3, 6];
                cur_svg_width = svg_width_m;
                cur_svg_height = svg_height_m;
                break;
            case 'l':
                depth = 20;
                tableDistribution = [8, 15];
                cur_svg_width = svg_width_l;
                cur_svg_height = svg_height_l;
                break;
        }

        g = new GraphGenerator(depth, seed, tableDistribution)
        g = g.generate()
        
        g.setExactWeights()
        g.sortGraph()

        switch (algorithmName) {
            case 'sweep':
                algorithm = new Sweep(g)
                algorithm.arrange()
                break;
            case 'modified gansner':
                algorithm = new Gansner(g)
                algorithm.arrange()
                break;
            case 'lp':
                algorithm = new LPFormulation(g)
                algorithm.arrange()
                //g = lpTest()
                break;
            default:
                break;
        }

        g.setExactWeights()
        g.sortGraph()

        svg = rowDiv
                .append('div')
                .style('width', '33%')
                .append('svg')
                .attr('class', 'vis-svg')
                .attr('easypz', '{"applyTransformTo":"svg > *"}')
                .attr("preserveAspectRatio", "xMinYMin meet")
                .attr("viewBox", "0 0 " + cur_svg_width + " " + cur_svg_height)

        drawGraph(svg, g, algorithm)
    }

    let form = document.createElement("div")
    let label1 = document.createElement("label")
    let input = document.createElement("input")
    let input2 = document.createElement("button")
    input.id = "fseed"
    input.type = "text"
    input.name = "fseed"
    label1.innerHTML = "seed: "
    label1.for = "fseed"
    form.append(label1)
    form.append(input)
    input2.innerHTML = "Generate"
    form.append(input2) 
    document.body.append(form)
    form.style.margin = "10px"
    form.style.fontFamily = "Arial"
    input2.onclick = () => {
        makeAllGraphs(input.value)
    }

    makeAllGraphs = (seed) => {
        d3.selectAll(".vis-svg").remove()
        d3.selectAll(".crossing_count").remove()
        d3.selectAll('.algorithm_header').remove()
        d3.selectAll('.algorithm_explanation').remove()
        d3.selectAll('.rowDiv').remove()

        d3.select('body').append('div')
            .text("Original")
            .attr('class', 'algorithm_header')

        rowDiv = d3.select('body').append('div')
            .style('width', '150%')
            .style('height', svg_height)
            .style('display', 'flex')
            .attr('class', 'rowDiv')

        makeGraphWithAlgorithm(rowDiv, seed, 's')
        makeGraphWithAlgorithm(rowDiv, seed, 'm')
        makeGraphWithAlgorithm(rowDiv, seed, 'l')

        // ***
        // SWEEP
        // ***

        d3.select('body').append('div')
            .text("Sweep")
            .attr('class', 'algorithm_header')

        d3.select('body').append('tspan')
            .attr('class', 'algorithm_explanation')
            .html("Simple one-pass sweep, first starting from the left, then from the right. <br>"
                + "Tries swapping each element with the next in the same column, then checks if the number of crossings is lower. If it is, it keeps going, if not, it reverses the swap and keeps going.")

        rowDiv = d3.select('body').append('div')
            .style('width', '150%')
            .style('height', svg_height)
            .style('display', 'flex')
            .attr('class', 'rowDiv')

        makeGraphWithAlgorithm(rowDiv, seed, 's', 'sweep')
        makeGraphWithAlgorithm(rowDiv, seed, 'm', 'sweep')
        makeGraphWithAlgorithm(rowDiv, seed, 'l', 'sweep')

        // ***
        // GANSNER
        // ***

        d3.select('body').append('div')
            .text("Modified Gansner [1993] (GraphViz's dot)")
            .attr('class', 'algorithm_header')

        d3.select('body').append('tspan')
            .attr('class', 'algorithm_explanation')
            .html("This should be the implementation that is closest to what GraphViz was doing to queryvis graphs. <br>"
                + "Each node is assigned a weight that is the median of the weights of the linked tables. <br>"
                + "Differently from Gansner (1993), this implementation manages groups of nodes that should be kept adjacent (attributes in a table). "
                + "I believe GraphViz does this as well, by treating the groups of nodes as subproblems. <br> <br>"
                + "Note: this implementation does not deal with same-rank edges, as they are not mentioned in Gansner's paper. GraphViz does not manage same-rank edges as well.")

        rowDiv = d3.select('body').append('div')
            .style('width', '150%')
            .style('height', svg_height)
            .style('display', 'flex')
            .attr('class', 'rowDiv')

        makeGraphWithAlgorithm(rowDiv, seed, 's', 'modified gansner')
        makeGraphWithAlgorithm(rowDiv, seed, 'm', 'modified gansner')
        makeGraphWithAlgorithm(rowDiv, seed, 'l', 'modified gansner')

        // ***
        // LINEAR PROGRAMMING
        // ***

        d3.select('body').append('div')
            .text("Linear programming formulation")
            .attr('class', 'algorithm_header')

        rowDiv = d3.select('body').append('div')
            .style('width', '150%')
            .style('height', svg_height)
            .style('display', 'flex')
            .attr('class', 'rowDiv')

        makeGraphWithAlgorithm(rowDiv, seed, 's', 'lp')
        makeGraphWithAlgorithm(rowDiv, seed, 'm', 'lp')
        makeGraphWithAlgorithm(rowDiv, seed, 'l', 'lp')
    }

    makeAllGraphs("hello.")

</script>

</html>
